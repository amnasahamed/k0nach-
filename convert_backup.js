const fs = require('fs');

// Read the backup file
const backupData = JSON.parse(fs.readFileSync('./frontend/components/taskmaster_backup_2025-12-15 (2).json', 'utf8'));

// Convert students - they mostly match already
const convertedStudents = backupData.students.map(student => {
  // Ensure phone is not empty
  let phone = student.phone || '0000000000';
  if (phone.trim() === '') {
    phone = '0000000000';
  }
  
  return {
    id: student.id,
    name: student.name || 'Unknown',
    email: student.email || 'unknown@example.com',
    phone: phone,
    university: student.university,
    remarks: student.remarks,
    isFlagged: student.isFlagged || false,
    referredBy: student.referredBy,
    createdAt: student.createdAt,
    updatedAt: student.updatedAt
  };
}).filter(student => student.name && student.email && student.phone);

// Convert writers - this is where the main difference is
const convertedWriters = backupData.writers.map((writer, index) => {
  // Extract phone number from contact if it's a phone number
  let phone = '';
  if (writer.contact && /^\d+$/.test(writer.contact)) {
    phone = writer.contact;
  } else {
    // Generate a unique dummy phone number if contact isn't a valid phone
    // Use index to make each phone number unique
    phone = `123456789${index}`;
  }
  
  // Ensure phone is exactly 10 digits
  if (phone.length !== 10) {
    // Take last 10 digits or pad with zeros
    phone = phone.replace(/\D/g, '').slice(-10).padStart(10, '0');
    if (phone.length > 10) {
      phone = phone.substring(0, 10);
    } else if (phone.length < 10) {
      phone = phone.padEnd(10, '0');
    }
  }
  
  // Convert rating structure
  let rating = 0;
  if (writer.rating && typeof writer.rating === 'object') {
    // Average of quality and punctuality
    const quality = parseFloat(writer.rating.quality) || 0;
    const punctuality = parseFloat(writer.rating.punctuality) || 0;
    rating = (quality + punctuality) / 2;
  } else if (typeof writer.rating === 'number') {
    rating = writer.rating;
  } else if (typeof writer.rating === 'string') {
    rating = parseFloat(writer.rating) || 0;
  }
  
  // Ensure rating is a valid number
  if (isNaN(rating)) {
    rating = 0;
  }
  
  return {
    // id will be auto-generated by the backend since it's INTEGER AUTO_INCREMENT
    phone: phone,
    name: writer.name || 'Unknown Writer',
    email: writer.contact && writer.contact.includes('@') ? writer.contact : 'unknown@example.com',
    rating: rating,
    totalAssignments: 0,
    completedAssignments: 0,
    onTimeDeliveries: 0,
    level: 'Bronze',
    points: 0,
    streak: 0,
    lastActive: writer.updatedAt || writer.createdAt || new Date().toISOString(),
    createdAt: writer.createdAt,
    updatedAt: writer.updatedAt
  };
}).filter(writer => writer.name && writer.phone);

// Create a mapping of old writer IDs to new writer IDs
// Based on the order in the backup data:
// Index 0: Satish (6ljif4d6m) -> will become ID 11
// Index 1: Sohini (4oyudooc1) -> will become ID 12
// Index 2: Sohini (gyvvqbsdx) -> will become ID 13
// Index 3: Souvik (264as9uqz) -> will become ID 14
// We'll let the smart import script handle the writer ID mapping
const writerIdMap = {};

// Convert assignments - mostly match but need some adjustments
const convertedAssignments = backupData.assignments.map(assignment => {
  // Map string status to proper enum values if needed
  let status = assignment.status;
  if (status === 'Pending') status = 'Pending';
  if (status === 'In Progress') status = 'In Progress';
  if (status === 'Under Review') status = 'Under Review';
  if (status === 'Completed') status = 'Completed';
  if (status === 'Cancelled') status = 'Cancelled';
  
  // Map string type to proper enum values if needed
  let type = assignment.type;
  if (type === 'Essay') type = 'Essay';
  if (type === 'Dissertation') type = 'Dissertation';
  if (type === 'Report') type = 'Report';
  if (type === 'Presentation') type = 'Presentation';
  if (type === 'Other') type = 'Other';
  
  // Map string priority to proper enum values if needed
  let priority = assignment.priority;
  if (priority === 'High') priority = 'High';
  if (priority === 'Medium') priority = 'Medium';
  if (priority === 'Low') priority = 'Low';
  
  // Map old writer IDs to new writer IDs
  let writerId = assignment.writerId;
  if (writerId && writerIdMap[writerId]) {
    writerId = writerIdMap[writerId];
  }
  
  return {
    id: assignment.id,
    studentId: assignment.studentId,
    writerId: writerId,
    title: assignment.title,
    type: type,
    subject: assignment.subject,
    level: assignment.level,
    deadline: assignment.deadline,
    status: status,
    priority: priority,
    documentLink: assignment.documentLink,
    wordCount: assignment.wordCount || 0,
    costPerWord: assignment.costPerWord || 0,
    writerCostPerWord: assignment.writerCostPerWord || 0,
    price: assignment.price,
    paidAmount: assignment.paidAmount,
    writerPrice: assignment.writerPrice || 0,
    writerPaidAmount: assignment.writerPaidAmount || 0,
    sunkCosts: assignment.sunkCosts || 0,
    isDissertation: assignment.isDissertation,
    totalChapters: assignment.totalChapters,
    chapters: assignment.chapters,
    description: assignment.description,
    createdAt: assignment.createdAt,
    updatedAt: assignment.updatedAt,
    activityLog: [],
    paymentHistory: [],
    statusHistory: [],
    attachments: []
  };
});

// Create the converted data structure
const convertedData = {
  students: convertedStudents,
  writers: convertedWriters,
  assignments: convertedAssignments
};

// Save to a new file
fs.writeFileSync('./converted_backup.json', JSON.stringify(convertedData, null, 2));
console.log('Backup conversion completed. Converted data saved to converted_backup.json');
console.log(`Converted ${convertedStudents.length} students, ${convertedWriters.length} writers, and ${convertedAssignments.length} assignments.`);